# templates/pipelines/python.yml
# Complete CI/CD pipeline for Python applications
#
# Features:
#   - pip dependency caching
#   - pytest with coverage
#   - SonarQube code quality analysis
#   - Quality gate validation
#   - Docker image build with Kaniko
#   - GitOps deployment via ArgoCD
#
# Usage in your project's .gitlab-ci.yml:
#   include:
#     - project: 'daitics-com/ci-cd-templates'
#       file: '/templates/pipelines/python.yml'
#
#   variables:
#     APP_NAME: my-python-app
#     PYTHON_VERSION: "3.12"

include:
  - local: '/templates/base/stages.yml'

# Global variables
variables:
  PYTHON_VERSION: "3.12"
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.pip-cache"
  REGISTRY_HOST: "gitlab:5050"

# Cache pip packages
cache:
  key: "${CI_COMMIT_REF_SLUG}-python"
  paths:
    - .pip-cache/
    - venv/

# =============================================================================
# BUILD STAGE
# =============================================================================

install:
  stage: .pre
  image: python:${PYTHON_VERSION}-slim
  script:
    - echo "Setting up Python environment..."
    - python -m venv venv
    - source venv/bin/activate
    - pip install --upgrade pip
    - |
      if [ -f requirements.txt ]; then
        pip install -r requirements.txt
      fi
    - |
      if [ -f requirements-dev.txt ]; then
        pip install -r requirements-dev.txt
      fi
    - pip install pytest pytest-cov
    - echo "Dependencies installed"
  artifacts:
    paths:
      - venv/
    expire_in: 1 day

build:
  stage: build
  image: python:${PYTHON_VERSION}-slim
  script:
    - echo "Building Python application..."
    - source venv/bin/activate
    - |
      if [ -f setup.py ]; then
        python setup.py build
      elif [ -f pyproject.toml ]; then
        pip install build
        python -m build
      fi
    - echo "Build completed"
  artifacts:
    paths:
      - dist/
      - build/
    expire_in: 7 days
  needs:
    - install

# =============================================================================
# TEST STAGE
# =============================================================================

test:
  stage: test
  image: python:${PYTHON_VERSION}-slim
  script:
    - echo "Running tests..."
    - source venv/bin/activate
    - pytest --cov=. --cov-report=xml --cov-report=html --junitxml=junit.xml -v
    - echo "Tests completed"
  coverage: '/TOTAL.*\s+(\d+%)/'
  artifacts:
    when: always
    reports:
      junit: junit.xml
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    paths:
      - htmlcov/
      - coverage.xml
    expire_in: 30 days
  needs:
    - install

lint:
  stage: test
  image: python:${PYTHON_VERSION}-slim
  script:
    - echo "Running linters..."
    - source venv/bin/activate
    - pip install flake8 black isort
    - flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics || true
    - black --check . || echo "Black formatting check failed"
    - isort --check-only . || echo "Import sorting check failed"
    - echo "Linting completed"
  allow_failure: true
  needs:
    - install

# =============================================================================
# CODE QUALITY STAGE
# =============================================================================

sonarqube-scan:
  stage: code-quality
  image:
    name: sonarsource/sonar-scanner-cli:5.0.1
    entrypoint: [""]
  variables:
    GIT_DEPTH: "0"
  before_script:
    - apk add --no-cache curl jq

    # Authenticate with Vault
    - |
      VAULT_TOKEN=$(curl -sk --request POST \
        --data "{\"role_id\":\"${VAULT_ROLE_ID}\",\"secret_id\":\"${VAULT_SECRET_ID}\"}" \
        ${VAULT_ADDR}/v1/auth/approle/login | jq -r '.auth.client_token')

    - |
      SONAR_TOKEN=$(curl -sk --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/secret/data/cicd/sonarqube | jq -r '.data.data.ci_token')
      export SONAR_TOKEN
      echo "SonarQube token retrieved"
  script:
    - echo "Running SonarQube analysis..."
    - |
      sonar-scanner \
        -Dsonar.host.url=${SONAR_HOST_URL} \
        -Dsonar.token=${SONAR_TOKEN} \
        -Dsonar.projectKey=${CI_PROJECT_PATH_SLUG} \
        -Dsonar.projectName="${CI_PROJECT_NAME}" \
        -Dsonar.projectVersion=${CI_COMMIT_SHORT_SHA} \
        -Dsonar.sources=. \
        -Dsonar.exclusions="**/venv/**,**/.venv/**,**/__pycache__/**,**/tests/**,**/*_test.py,**/test_*.py" \
        -Dsonar.python.coverage.reportPaths=coverage.xml \
        -Dsonar.python.xunit.reportPath=junit.xml
    - echo "SonarQube analysis completed"
    - echo "View results: ${SONAR_HOST_URL}/dashboard?id=${CI_PROJECT_PATH_SLUG}"
  needs:
    - build
    - test
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

quality-gate:
  stage: code-quality
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
    - |
      VAULT_TOKEN=$(curl -sk --request POST \
        --data "{\"role_id\":\"${VAULT_ROLE_ID}\",\"secret_id\":\"${VAULT_SECRET_ID}\"}" \
        ${VAULT_ADDR}/v1/auth/approle/login | jq -r '.auth.client_token')
    - |
      SONAR_TOKEN=$(curl -sk --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/secret/data/cicd/sonarqube | jq -r '.data.data.ci_token')
      export SONAR_TOKEN
  script:
    - echo "Checking Quality Gate..."
    - sleep 10
    - |
      STATUS=$(curl -sk -u "${SONAR_TOKEN}:" \
        "${SONAR_HOST_URL}/api/qualitygates/project_status?projectKey=${CI_PROJECT_PATH_SLUG}" \
        | jq -r '.projectStatus.status')
      echo "Quality Gate: ${STATUS}"
      if [ "${STATUS}" != "OK" ] && [ "${STATUS}" != "WARN" ]; then
        echo "Quality Gate FAILED!"
        exit 1
      fi
      echo "Quality Gate PASSED!"
  needs:
    - sonarqube-scan
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# =============================================================================
# PACKAGE STAGE
# =============================================================================

build-image:
  stage: package
  image:
    name: gcr.io/kaniko-project/executor:v1.23.2-debug
    entrypoint: [""]
  variables:
    IMAGE_TAG: "${REGISTRY_HOST}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}"
    IMAGE_LATEST: "${REGISTRY_HOST}/${CI_PROJECT_PATH}:latest"
  script:
    - echo "Building Docker image with Kaniko"
    - mkdir -p /kaniko/.docker
    - echo "{\"auths\":{\"${REGISTRY_HOST}\":{\"auth\":\"$(printf "%s:%s" "${CI_REGISTRY_USER}" "${CI_REGISTRY_PASSWORD}" | base64 | tr -d '\n')\"}}}" > /kaniko/.docker/config.json
    - |
      /kaniko/executor \
        --context "${CI_PROJECT_DIR}" \
        --dockerfile "${CI_PROJECT_DIR}/Dockerfile" \
        --destination "${IMAGE_TAG}" \
        --destination "${IMAGE_LATEST}" \
        --build-arg BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ) \
        --build-arg VCS_REF=${CI_COMMIT_SHORT_SHA} \
        --insecure \
        --skip-tls-verify \
        --cache=true \
        --cache-ttl=24h
    - echo "Image: ${IMAGE_TAG}"
  needs:
    - build
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop" || $CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'

# =============================================================================
# DEPLOY STAGE
# =============================================================================

deploy:dev:
  stage: deploy
  image: alpine/git:latest
  variables:
    ENVIRONMENT: "development"
    MANIFEST_REPO_URL: "http://gitlab-webservice-default.gitlab-system.svc.cluster.local:8181/daitics-com/k8s-manifests.git"
  before_script:
    - apk add --no-cache curl jq
    - |
      VAULT_TOKEN=$(curl -sk --request POST \
        --data "{\"role_id\":\"${VAULT_ROLE_ID}\",\"secret_id\":\"${VAULT_SECRET_ID}\"}" \
        ${VAULT_ADDR}/v1/auth/approle/login | jq -r '.auth.client_token')
    - |
      GITLAB_DEPLOY_TOKEN=$(curl -sk --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/secret/data/cicd/gitlab | jq -r '.data.data.deploy_token')
      export GITLAB_DEPLOY_TOKEN
  script:
    - echo "Deploying to ${ENVIRONMENT}..."
    - |
      REPO_URL_WITH_AUTH=$(echo "${MANIFEST_REPO_URL}" | sed "s|http://|http://deploy:${GITLAB_DEPLOY_TOKEN}@|")
      git clone "${REPO_URL_WITH_AUTH}" k8s-manifests
      cd k8s-manifests
    - git config user.email "gitlab-ci@daitics.local"
    - git config user.name "GitLab CI"
    - |
      MANIFEST_PATH="environments/${ENVIRONMENT}/${CI_PROJECT_NAME}/deployment.yaml"
      if [ -f "$MANIFEST_PATH" ]; then
        NEW_IMAGE="${REGISTRY_HOST}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}"
        sed -i "s|image:.*|image: ${NEW_IMAGE}|g" "${MANIFEST_PATH}"
        git add . && git commit -m "Deploy ${CI_PROJECT_NAME}:${CI_COMMIT_SHORT_SHA} to ${ENVIRONMENT}" && git push
        echo "Deployment updated - ArgoCD will sync"
      else
        echo "Manifest not found at ${MANIFEST_PATH}"
      fi
  environment:
    name: development
    url: https://dev-${CI_PROJECT_NAME}.service.daitics.local
  needs:
    - build-image
    - quality-gate
  rules:
    - if: '$CI_COMMIT_BRANCH == "develop"'
      when: on_success  # Automatic - no approval

deploy:prod:
  stage: deploy
  image: alpine/git:latest
  variables:
    ENVIRONMENT: "production"
    MANIFEST_REPO_URL: "http://gitlab-webservice-default.gitlab-system.svc.cluster.local:8181/daitics-com/k8s-manifests.git"
  before_script:
    - apk add --no-cache curl jq
    - |
      VAULT_TOKEN=$(curl -sk --request POST \
        --data "{\"role_id\":\"${VAULT_ROLE_ID}\",\"secret_id\":\"${VAULT_SECRET_ID}\"}" \
        ${VAULT_ADDR}/v1/auth/approle/login | jq -r '.auth.client_token')
    - |
      GITLAB_DEPLOY_TOKEN=$(curl -sk --header "X-Vault-Token: ${VAULT_TOKEN}" \
        ${VAULT_ADDR}/v1/secret/data/cicd/gitlab | jq -r '.data.data.deploy_token')
      export GITLAB_DEPLOY_TOKEN
  script:
    - echo "Deploying to ${ENVIRONMENT}..."
    - |
      REPO_URL_WITH_AUTH=$(echo "${MANIFEST_REPO_URL}" | sed "s|http://|http://deploy:${GITLAB_DEPLOY_TOKEN}@|")
      git clone "${REPO_URL_WITH_AUTH}" k8s-manifests
      cd k8s-manifests
    - git config user.email "gitlab-ci@daitics.local"
    - git config user.name "GitLab CI"
    - |
      MANIFEST_PATH="environments/${ENVIRONMENT}/${CI_PROJECT_NAME}/deployment.yaml"
      if [ -f "$MANIFEST_PATH" ]; then
        NEW_IMAGE="${REGISTRY_HOST}/${CI_PROJECT_PATH}:${CI_COMMIT_SHORT_SHA}"
        sed -i "s|image:.*|image: ${NEW_IMAGE}|g" "${MANIFEST_PATH}"
        git add . && git commit -m "Deploy ${CI_PROJECT_NAME}:${CI_COMMIT_SHORT_SHA} to ${ENVIRONMENT}" && git push
        echo "Deployment updated - ArgoCD will sync"
      else
        echo "Manifest not found at ${MANIFEST_PATH}"
      fi
  environment:
    name: production
    url: https://${CI_PROJECT_NAME}.service.daitics.local
  needs:
    - build-image
    - quality-gate
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" || $CI_COMMIT_BRANCH == "master"'
      when: manual  # Requires approval